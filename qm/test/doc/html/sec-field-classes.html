<HTML
><HEAD
><TITLE
>Field Classes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="QMTest: User's Guide and Reference"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending QMTest"
HREF="chap-test-extension.html"><LINK
REL="PREVIOUS"
TITLE="Extension Classes"
HREF="sec-extension-classes.html"><LINK
REL="NEXT"
TITLE="Writing Test Classes"
HREF="sec-writing-test-classes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="qm.css"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>QMTest: User's Guide and Reference</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-extension-classes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. Extending QMTest</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-writing-test-classes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="sec-field-classes"
></A
>4.2. Field Classes</H1
><P
>A <A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/Field.html"
TARGET="_top"
><TT
CLASS="classname"
>Field</TT
></A
> is a named, typed component of a data
  structure.  A <TT
CLASS="classname"
>Field</TT
> can read and write XML
  representations of values, generate HTML representations of values,
  or present HTML forms that permit the user to update the value of
  the field.  There are several classes derived from
  <TT
CLASS="classname"
>Field</TT
> that you can use in extension classes.
  If none of those classes satisfy your needs, you can create a new
  class derived from <TT
CLASS="classname"
>Field</TT
>.</P
><P
>Every <TT
CLASS="classname"
>Field</TT
> has a name.  The name is a
  string, and must be a valid Python identifier.  (The reason for this
  restriction is that instances of <TT
CLASS="classname"
>Extension</TT
>
  have an instance variables corresponding to each field.)  A
  <TT
CLASS="classname"
>Field</TT
> may also have a title, which is used
  when presenting the <TT
CLASS="classname"
>Field</TT
> to the user.  The
  title need not be a valid Python identifier.  For example, the
  <TT
CLASS="classname"
>RSHTarget</TT
> class has an argument whose name is
  <TT
CLASS="literal"
>host</TT
>, but whose title is <TT
CLASS="literal"
>Remote Host
  Name</TT
>.  When accessing an instance of this class, the
  programmer refers to <TT
CLASS="literal"
>self.host</TT
>.  In the GUI,
  however, the user will see the value presented as <TT
CLASS="literal"
>Remote
  Host Name</TT
>.</P
><P
>A <TT
CLASS="classname"
>Field</TT
> may have an associated
  description, which is a longer explanation of the
  <TT
CLASS="classname"
>Field</TT
> and its purpose.  This information is
  presented to the user by the GUI.</P
><P
>A <TT
CLASS="classname"
>Field</TT
> may have a default value.  The
  default value is used if no explicit value is provided for the
  field.</P
><P
>This example code from <TT
CLASS="classname"
>RSHTarget</TT
> shows
  how a <TT
CLASS="classname"
>Field</TT
> is constructed:
  <PRE
CLASS="programlisting"
>&#13;   qm.fields.TextField(
        name="remote_shell",
        title="Remote Shell Program",
        description="""The path to the remote shell program.

         The name of the program that can be used to create a
         remote shell.  This program must accept the same command
         line arguments as the 'rsh' program.""",
         default_value="ssh")

  </PRE
>See the internal documentation for <A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/Field.html"
TARGET="_top"
><TT
CLASS="classname"
>Field</TT
></A
>
   for complete interface documentation.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="sec-field-classes-list"
></A
>4.2.1. Built-In Field Classes</H2
><P
>QMTest comes with several useful field classes:
    <P
></P
><UL
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/IntegerField.html"
TARGET="_top"
><TT
CLASS="classname"
>IntegerField</TT
></A
> stores integers.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/TextField.html"
TARGET="_top"
><TT
CLASS="classname"
>TextField</TT
></A
> stores strings.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/EnumerationField.html"
TARGET="_top"
><TT
CLASS="classname"
>EnumerationField</TT
></A
> stores one of a
      set of (statically determined) possible values.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/ChoiceField.html"
TARGET="_top"
><TT
CLASS="classname"
>ChoiceField</TT
></A
> stores one of a
      set of (dynamically determined) possible values.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/BooleanField.html"
TARGET="_top"
><TT
CLASS="classname"
>BooleanField</TT
></A
> stores a boolean value.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/TimeField.html"
TARGET="_top"
><TT
CLASS="classname"
>TimeField</TT
></A
> stores a date and time.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/AttachmentField.html"
TARGET="_top"
><TT
CLASS="classname"
>AttachmentField</TT
></A
> stores arbitrary
      data.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/SetField.html"
TARGET="_top"
><TT
CLASS="classname"
>SetField</TT
></A
> stores multiple values of the
      same type.</P
></LI
><LI
><P
><A
HREF="http://www.codesourcery.com/public/qmtest/qm-2.2/internals/qm/fields/TupleField.html"
TARGET="_top"
><TT
CLASS="classname"
>TupleField</TT
></A
> stores a fixed number of other fields.</P
></LI
></UL
>
   </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="sec-field-classes-writing"
></A
>4.2.2. Writing Field Classes</H2
><P
>Before writing any code, you should decide what kind of data
   your field class will store.  For example, will your field class
   store arbitrary strings?  Or only strings that match a particular
   regular expression?  Or will your field class store images?  Once
   you have decided this question, you can write the
   <TT
CLASS="function"
>Validate</TT
> function for your field class.  This
   function checks an input value (a Python object) for validity.
   <TT
CLASS="function"
>Validate</TT
> can return a modified version of the
   value.  For example, if the field stores strings, you could choose
   to accept an integer as an input to <TT
CLASS="function"
>Validate</TT
>
   and convert the integer to a string before returning it.</P
><P
>The <TT
CLASS="function"
>FormatValueAsHtml</TT
> function produces
   an HTML representation of the value.  You must define this function
   so that the GUI can display the value of the field.  The
   <TT
CLASS="parameter"
><I
>style</I
></TT
> parameter indicates how the value
   should be displayed.  If the style is <TT
CLASS="literal"
>new</TT
> or
   <TT
CLASS="literal"
>edit</TT
>, the HTML representation returned should be
   a form that the user can use to set the value.  If the user does
   not modify the form, <TT
CLASS="function"
>ParseFormValue</TT
> should
   yield the value that was provided to
   <TT
CLASS="function"
>FormatValueAsHtml</TT
>.</P
><P
>The <TT
CLASS="function"
>MakeDomNodeForValue</TT
> and
   <TT
CLASS="function"
>GetValueFromDomNode</TT
> functions convert values
   to and from XML format.  The <TT
CLASS="function"
>FormatValueAsText</TT
>
   and <TT
CLASS="function"
>ParseTextValue</TT
> functions convert to and
   from plain text.  As with <TT
CLASS="function"
>FormatValueAsHtml</TT
>
   and <TT
CLASS="function"
>ParseFormValue</TT
>, these pairs of functions
   should be inverses of one another.</P
><P
>The <TT
CLASS="function"
>ParseTextValue</TT
>,
   <TT
CLASS="function"
>ParseFormValue</TT
>, and
   <TT
CLASS="function"
>GetValueFromDomNode</TT
> functions should use
   <TT
CLASS="function"
>Validate</TT
> to check that the values produced are
   permitted by the <TT
CLASS="classname"
>Field</TT
>.  In this way,
   derived classes that want to restrict the set of valid values, but
   are otherwise content to use the base class functionality, need
   only provide a new implementation of
   <TT
CLASS="function"
>Validate</TT
>.</P
><P
>All of the functions which read and write
   <TT
CLASS="classname"
>Field</TT
> values may raise exceptions if they
   cannot complete their tasks.  The caller of the
   <TT
CLASS="classname"
>Field</TT
> is responsible for handling the
   exception if it occurs.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-extension-classes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-writing-test-classes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Extension Classes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="chap-test-extension.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Writing Test Classes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>